from odoo import api, fields, models
from odoo.exceptions import ValidationError

class EstateProperty(models.Model):
    _name = "estate.property"
    _description = "Real Estate Property"
    _order = "state desc, expected_price desc, id desc"

    # --- Core fields ---
    name = fields.Char(required=True)
    description = fields.Text()
    state = fields.Selection([
        ('new', 'New'),
        ('offer_received', 'Offer Received'),
        ('offer_accepted', 'Offer Accepted'),
        ('sold', 'Sold'),
        ('canceled', 'Canceled'),
    ], default='new', required=True, index=True)

    currency_id = fields.Many2one(
        "res.currency",
        string="Currency",
        default=lambda self: self.env.company.currency_id.id,
        required=True,
    )
    expected_price = fields.Monetary(required=True, currency_field="currency_id")
    selling_price = fields.Monetary(readonly=True, copy=False, currency_field="currency_id")

    # relations (assumes estate.property.offer with property_id exists)
    offer_ids = fields.One2many("estate.property.offer", "property_id", string="Offers")

    # computed stats
    offers_count = fields.Integer(string="Offers", compute="_compute_offer_stats", store=True)
    best_price = fields.Monetary(
        string="Best Offer",
        compute="_compute_offer_stats",
        currency_field="currency_id",
        store=True,
    )

    @api.depends('offer_ids.price', 'offer_ids.status')
    def _compute_offer_stats(self):
        for rec in self:
            valid = rec.offer_ids.filtered(lambda o: o.status != 'refused')
            prices = valid.mapped('price')
            rec.offers_count = len(prices)
            rec.best_price = max(prices) if prices else 0.0

    # ====== HARD GUARANTEES (server-side) ======
    @api.constrains('expected_price')
    def _check_expected_price_positive(self):
        for rec in self:
            if rec.expected_price is None or rec.expected_price <= 0:
                raise ValidationError("Expected price must be strictly positive.")

    @api.constrains('selling_price', 'state')
    def _check_selling_when_sold(self):
        for rec in self:
            if rec.state == 'sold' and (rec.selling_price is None or rec.selling_price <= 0):
                raise ValidationError("A sold property must have a positive selling price.")

    def write(self, vals):
        """Block unsafe edits when sold/canceled."""
        protected_states = {'sold', 'canceled'}
        protected_fields = {
            'name', 'description', 'expected_price', 'garden', 'garden_area',
            'garden_orientation', 'bedrooms', 'living_area', 'facades',
            'garage', 'postcode', 'date_availability', 'currency_id'
        }
        for rec in self:
            if rec.state in protected_states and protected_fields.intersection(vals.keys()):
                raise ValidationError("You cannot edit key fields of a sold/canceled property.")
        return super().write(vals)

    def unlink(self):
        if any(s.state not in ('new', 'canceled') for s in self):
            raise ValidationError("Only 'New' or 'Canceled' properties can be deleted.")
        return super().unlink()

    # ====== Buttons with checks ======
    def action_mark_canceled(self):
        for rec in self:
            if rec.state == 'sold':
                raise ValidationError("Sold properties cannot be canceled.")
            rec.state = 'canceled'
        return True

    def action_mark_sold(self):
        """Sell only if there is exactly one accepted offer; set selling_price from it."""
        for rec in self:
            if rec.state == 'canceled':
                raise ValidationError("Canceled properties cannot be sold.")
            accepted = rec.offer_ids.filtered(lambda o: o.status == 'accepted')
            if len(accepted) != 1:
                raise ValidationError("Exactly one accepted offer is required to sell.")
            rec.selling_price = accepted.price
            rec.state = 'sold'
        return True

    def action_open_best_offer(self):
        self.ensure_one()
        best = self.offer_ids.sorted(lambda o: o.price, reverse=True)[:1]
        if best:
            return {
                "type": "ir.actions.act_window",
                "res_model": "estate.property.offer",
                "res_id": best.id,
                "view_mode": "form",
                "target": "current",
            }
        return False
