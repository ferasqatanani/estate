from odoo import api, fields, models
from odoo.exceptions import ValidationError

class EstateProperty(models.Model):
    _name = "estate.property"
    _description = "Real Estate Property"

    # Basic fields (Day 3)
    name = fields.Char(string="Title", required=True)
    description = fields.Text(string="Description")
    postcode = fields.Char(string="Postcode")
    date_availability = fields.Date(string="Available From")
    expected_price = fields.Float(string="Expected Price", required=True, default=0.0)
    selling_price = fields.Float(string="Selling Price", readonly=True, copy=False)
    bedrooms = fields.Integer(string="Bedrooms", default=2)
    living_area = fields.Integer(string="Living Area (sqm)")
    facades = fields.Integer(string="Facades")
    garage = fields.Boolean(string="Has Garage?")
    garden = fields.Boolean(string="Has Garden?")
    garden_area = fields.Integer(string="Garden Area (sqm)")
    garden_orientation = fields.Selection(
        string="Garden Orientation",
        selection=[("north", "North"), ("south", "South"), ("east", "East"), ("west", "West")],
    )

    # Day 7: relations
    property_type_id = fields.Many2one("estate.property.type", string="Property Type")
    tag_ids = fields.Many2many("estate.property.tag", string="Tags")
    salesperson_id = fields.Many2one("res.users", string="Salesperson", default=lambda self: self.env.user)
    buyer_id = fields.Many2one("res.partner", string="Buyer")

    # Day 8: compute fields
    total_area = fields.Integer(
        string="Total Area (sqm)",
        compute="_compute_total_area",
        store=True,
    )
    best_price = fields.Float(
        string="Best Price (90%)",
        compute="_compute_best_price",
        store=True,
    )

    # Day 9: state machine + actions
    state = fields.Selection(
        [
            ("new", "New"),
            ("sold", "Sold"),
            ("canceled", "Canceled"),
        ],
        default="new",
        copy=False,
    )

    _sql_constraints = [
        # Day 10: SQL constraint
        ("estate_property_check_expected_price_positive",
         "CHECK(expected_price > 0)",
         "Expected price must be strictly positive."),
    ]

    # ----- Computes (Day 8) -----
    @api.depends("living_area", "garden_area")
    def _compute_total_area(self):
        for rec in self:
            la = rec.living_area or 0
            ga = rec.garden_area or 0
            rec.total_area = la + ga

    @api.depends("expected_price")
    def _compute_best_price(self):
        for rec in self:
            rec.best_price = (rec.expected_price or 0.0) * 0.90

    # ----- Onchange (Day 8) -----
    @api.onchange("garden")
    def _onchange_garden(self):
        for rec in self:
            if rec.garden:
                rec.garden_area = rec.garden_area or 10
                rec.garden_orientation = rec.garden_orientation or "north"
            else:
                rec.garden_area = 0
                rec.garden_orientation = False

    # ----- Actions (Day 9) -----
    def action_mark_sold(self):
        for rec in self:
            if rec.state == "canceled":
                raise ValidationError("Canceled properties cannot be sold.")
            rec.state = "sold"
        return True

    def action_mark_canceled(self):
        for rec in self:
            if rec.state == "sold":
                raise ValidationError("Sold properties cannot be canceled.")
            rec.state = "canceled"
        return True

    # ----- Python constraints (Day 10) -----
    @api.constrains("selling_price", "expected_price")
    def _check_selling_vs_expected(self):
        for rec in self:
            sp = rec.selling_price or 0.0
            ep = rec.expected_price or 0.0
            if sp < 0:
                raise ValidationError("Selling price cannot be negative.")
            # Accept 0 while not yet sold; if sold and 0, you could tighten later
            if ep > 0 and sp > ep:
                raise ValidationError("Selling price cannot exceed expected price.")
